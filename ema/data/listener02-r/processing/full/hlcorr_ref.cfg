#[MHAVersion 4.4]
# Multiband compressor framework based on level in overlapping filter bands.
# parser "mhaconfig_in":
# 
# Input configuration
# parser "mhaconfig_out":
# 
# Output configuration
# Frequency unit
# keyword_list:[Hz kHz Oct Oct/3 Bark Erb ERB_Glasberg1990]
unit = Hz

# Frequencies
# vector<float>
f = [177 297 500 841 1414 2378 4000 6727 11314]

# frequency scale of filter bank
# keyword_list:[linear bark log erb ERB_Glasberg1990]
fscale = log

# filter overlap type
# keyword_list:[rect linear hanning exp gauss]
ovltype = rect

# relative plateau width
# float:[0,1[
plateau = 0

# frequency entry type
# keyword_list:[center edge]
ftype = center

# normalize broadband output amplitude
# bool
normalize = no

# Fail if frequency entries are non-monotonic (otherwise sort)
# bool
fail_on_nonmonotonic = yes

# Fail if center frequencies share the same FFT bin.
# bool
fail_on_unique_bins = yes

# Plugin name
# string
plugin_name = dc

# parser "burn":
# 
# Sample frequencies of data / Hz.
# vector<float>:[0,]
burn.f = [1000]

# Drain caused by vent / dB.
# vector<float>
burn.drain = [0]

# Conflux caused by vent / dB.
# vector<float>
burn.conflux = [-120]

# Maximum allowed gain / dB.
# vector<float>
burn.maxgain = [80]

# Maximum allowed output level / dB SPL (see notes in plugin doc).
# vector<float>
burn.mpo = [120]

# Time constant of afterburn gain modifier lowpass / s.
# float:[0,]
burn.taugain = 0.2

# Commit changes of configuration variables.
# keyword_list:[commit]
burn.commit = commit

# Bypass afterburn stage.
# bool
burn.bypass = yes

# parser "dc":
# 
# dynamic compression
# parser "dc.mhaconfig_in":
# 
# Input configuration
# parser "dc.mhaconfig_out":
# 
# Output configuration
# Input level is summed accross channels
# bool

# gaintable data in dB gains
# matrix<float>
dc.gtdata = [[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0];[0 0]]

# input level for first gain entry in dB SPL
# vector<float>
dc.gtmin = [-10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10 -10]

# level step size in dB
# vector<float>
dc.gtstep = [1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]

# RMS level averaging time constant in s
# vector<float>
dc.tau_rmslev = [0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02]

# attack time constant in s
# vector<float>
dc.tau_attack = [0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02 0.02]

# decay time constant in s
# vector<float>
dc.tau_decay = [0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1]

# Name of fftfilterbank plugin.  Used to extract frequency information.
# string
dc.fb = mbc

# name of audio channel number variable (empty: broadband)
# string
dc.chname = mbc_nch

# bypass dynamic compression
# bool
dc.bypass = no

# Client ID of last fit
# string
dc.clientid = 

# Gain rule of last fit
# string
dc.gainrule = 

# Preset name of last fit
# string
dc.preset = 



